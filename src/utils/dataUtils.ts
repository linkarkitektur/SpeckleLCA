import { toRaw, isProxy, isReactive, isRef } from 'vue'

import type { Product, Assembly } from '@/models/materialModel'

/**
 * Removes all nested reactivity and returns a raw object
 * @param obj json object to convert
 * @returns object without reactivity
 */
export function deepToRaw<T>(obj: T): T {
  // Base case: return if obj is null or not an object
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // If the value is a ref, unwrap it
  if (isRef(obj)) {
    return deepToRaw(obj.value) as unknown as T
  }

  // If the object is reactive (or a proxy), get its raw version first
  if (isReactive(obj) || isProxy(obj)) {
    obj = toRaw(obj)
  }

  // Handle arrays: map each element recursively
  if (Array.isArray(obj)) {
    return obj.map((item) => deepToRaw(item)) as unknown as T
  }

  // Handle plain objects: iterate over own keys and deep convert each value
  const rawObj: any = {}
  Object.keys(obj).forEach((key) => {
    rawObj[key] = deepToRaw(obj[key])
  })

  return rawObj as T
}

/**
 * Sanitizer for undefined fields in an object eg. for use in firebase
 * @param obj json object to sanitize
 * @returns returns sanitized object
 */
export function removeUndefinedFields(obj: any): any {
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  return Array.isArray(obj)
    ? obj.map((item) => removeUndefinedFields(item))
    : Object.entries(obj)
        .filter(([_, value]) => value !== undefined)
        .reduce((acc, [key, value]) => {
          acc[key] = removeUndefinedFields(value) // Recursively process nested objects
          return acc
        }, {} as any)
}

export const getEnumEntries = (enumObj: any) => {
  return Object.keys(enumObj)
    .filter((key) => isNaN(Number(key)))
    .map((key) => ({ label: key, value: enumObj[key] }))
}

/**
 * Generic recursive collector to traverse an objectâ€™s keys.
 * @param parameters Object to process
 * @param parameterSet Set to store collected keys/paths
 * @param prefix Current prefix for recursive calls
 * @param getValue Callback to generate the value to store based on the prefix and key
 */
function genericCollectParameters(
  parameters: Record<string, any>,
  parameterSet: Set<string>,
  prefix: string,
  getValue: (prefix: string, key: string) => string
): void {
  const guidOrHexRegex = /^(?:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}|[0-9a-fA-F]{32})$/

  Object.keys(parameters).forEach((key) => {
    const fullPath = prefix ? `${prefix}.${key}` : key

    // Skip keys that are GUIDs or 32-character hex strings
    if (guidOrHexRegex.test(key)) {
      return
    }

    const value = parameters[key]

    // Skip if the value is null, undefined, or an empty object/array
    if (
      value === null ||
      value === undefined ||
      (Array.isArray(value) && value.length === 0) ||
      (typeof value === 'object' && Object.keys(value).length === 0)
    ) {
      return
    }

    // Add to the set the value generated by the callback.
    parameterSet.add(getValue(prefix, key))

    // Recurse into arrays
    if (Array.isArray(value)) {
      value.forEach((element) => {
        if (typeof element === 'object' && element !== null) {
          genericCollectParameters(element, parameterSet, fullPath, getValue)
        }
      })
    } else if (typeof value === 'object') {
      // Recurse into plain objects
      genericCollectParameters(value, parameterSet, fullPath, getValue)
    }
  })
}

/**
 * Collects parameter keys (non-nested) recursively.
 * @param parameters Object to process
 * @param parameterSet Set to store keys
 */
export function collectParameters(
  parameters: Record<string, any>,
  parameterSet: Set<string>
): void {
  // Here we ignore the prefix and just add the key.
  genericCollectParameters(parameters, parameterSet, '', (_prefix, key) => key)
}

/**
 * Recursively collects nested parameter keys as dot-notated paths.
 * @param parameters Object to process
 * @param parameterSet Set to store dot-notated paths
 * @param prefix Current prefix for recursive calls
 */
export function collectParameterPaths(
  parameters: Record<string, any>,
  parameterSet: Set<string>,
  prefix = ''
): void {
  // Generate full path using prefix.
  genericCollectParameters(parameters, parameterSet, prefix, (prefix, key) =>
    prefix ? `${prefix}.${key}` : key
  )
}

/**
 * Chunks an array into smaller pieces of nested arrays
 * @param array 
 * @param chunkSize 
 * @returns chunkedArray
 */
export function chunkArray(array: any[], chunkSize: number) {
  const result = []
  for (let i = 0; i < array.length; i += chunkSize) {
    result.push(array.slice(i, i + chunkSize))
  }
  return result
}